/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.play.integrity.codelab.server.routes

import com.google.gson.Gson
import com.google.play.integrity.codelab.server.models.*
import com.google.play.integrity.codelab.server.util.*
import io.ktor.application.*
import io.ktor.request.*
import io.ktor.response.*
import io.ktor.routing.*

fun Application.registerCommandRoutes() {
    routing {
        commandRouting()
    }
}

fun Route.commandRouting() {
    route("/performCommand") {
        post {
            val incomingCommand = call.receive<ServerCommand>()
            // The incoming token string will either be:
            // 1) A token generated by the Play Integrity API
            // 2) An 'express' token, which is just a 16-byte random number
            //    converted to base64.
            if (incomingCommand.tokenString.length == EXPRESS_TOKEN_LENGTH) {
                // Express token, the command 'succeeds' as long as it's
                // in our express token list and hasn't expired.
                when (lookupExpressToken(incomingCommand.tokenString)) {
                    LookupResult.LOOKUP_FOUND -> {
                        call.respond(CommandResult(true, "Express success",
                            generateExpressToken().random))
                    }
                    LookupResult.LOOKUP_EXPIRED -> {
                        call.respond(CommandResult(false, "Express token expired", ""))
                    }
                    LookupResult.LOOKUP_NOT_FOUND -> {
                        call.respond(CommandResult(false, "Express token invalid", ""))
                    }
                }
            } else {
                // Play Integrity token
                val decodedTokenString = decryptToken(incomingCommand.tokenString)
                val integrityVerdictPayload = Gson().fromJson(decodedTokenString,
                    IntegrityVerdictPayload::class.java)
                if (integrityVerdictPayload != null) {
                    val integrityVerdict = integrityVerdictPayload.tokenPayloadExternal
                    when (validateCommand(incomingCommand.commandString, integrityVerdict)) {
                        ValidateResult.VALIDATE_SUCCESS -> {
                            call.respond(CommandResult(true,
                                summarizeVerdict(integrityVerdict), generateExpressToken().random))
                        }
                        ValidateResult.VALIDATE_NONCE_NOT_FOUND -> {
                            call.respond(CommandResult(false,
                                "Failed to find matching nonce", ""))
                        }
                        ValidateResult.VALIDATE_NONCE_EXPIRED -> {
                            call.respond(CommandResult(false,
                                "Token nonce expired", ""))
                        }
                        ValidateResult.VALIDATE_NONCE_MISMATCH -> {
                            call.respond(CommandResult(false,
                                "Token nonce didn't match command hash", ""))
                        }
                        ValidateResult.VALIDATE_INTEGRITY_FAIL -> {
                            // Integrity signals didn't pass our 'success' criteria,
                            // pass the verdict summary string
                            // back in the diagnostic field
                            call.respond(CommandResult(false,
                                summarizeVerdict(integrityVerdict), ""))
                        }
                    }
                } else {
                    val invalidToken = CommandResult(false, "Token invalid", "")
                    call.respond(invalidToken)
                }
            }
        }
    }
}