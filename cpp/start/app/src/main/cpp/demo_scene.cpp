/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "demo_scene.hpp"
#include "http_client.hpp"
#include "imgui.h"
#include "imgui_manager.hpp"
#include "client_manager.hpp"
#include "native_engine.hpp"
#include "server_urls.hpp"

extern "C" {
#include <GLES2/gl2.h>
}

#define ARRAY_COUNTOF(array) (sizeof(array) / sizeof(array[0]))

namespace {
    const ImVec4 TEXTCOLOR_WHITE = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
    const ImVec4 TEXTCOLOR_GREY = ImVec4(0.7f, 0.7f, 0.7f, 1.0f);
    const ImVec4 TEXTCOLOR_RED = ImVec4(1.0f, 0.2f, 0.2f, 1.0f);
    const ImVec4 TEXTCOLOR_GREEN = ImVec4(0.2f, 1.0f, 0.2f, 1.0f);

    /*
    const float UI_SCALE_MIN = 1.0f;
    const float UI_SCALE_MAX = 9.0f;
    const float UI_SCALE_STEP = 0.5f;
    const float FONT_SCALE_MIN = 1.0f;
    const float FONT_SCALE_MAX = 9.0f;
    const float FONT_SCALE_STEP = 1.0f;
    */
}

DemoScene::DemoScene() {
    mSimulatedClickState = SIMULATED_CLICK_NONE;
    mPointerDown = false;
    mPointerX = 0.0f;
    mPointerY = 0.0f;
    mTransitionStart = 0.0f;
    mServerRandom = "";
    mExpressToken = "";
    mSummary = "";
}

DemoScene::~DemoScene() {
}

void DemoScene::OnStartGraphics() {
    mTransitionStart = Clock();
}

void DemoScene::OnKillGraphics() {
}

void DemoScene::OnScreenResized(int width, int height) {
}

void DemoScene::DoFrame() {
    // clear screen
    glClearColor(0.0f, 0.0f, 0.25f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glDisable(GL_DEPTH_TEST);

    // Update the integrity manager to poll for any completed requests
    NativeEngine::GetInstance()->GetClientManager()->Update();

    // Update UI inputs to ImGui before beginning a new frame
    UpdateUIInput();
    ImGuiManager *imguiManager = NativeEngine::GetInstance()->GetImGuiManager();
    imguiManager->BeginImGuiFrame();
    RenderUI();
    imguiManager->EndImGuiFrame();

    glEnable(GL_DEPTH_TEST);
}

void DemoScene::RenderBackground() {
    // base classes override this to draw background
}

void DemoScene::OnButtonClicked(int buttonId) {
    // base classes override this to react to button clicks
}

void DemoScene::OnPointerDown(int pointerId, const struct PointerCoords *coords) {
    // If this event was generated by something that's not associated to the screen,
    // (like a trackpad), ignore it, because our UI is not driven that way.
    if (coords->isScreen) {
        mPointerDown = true;
        mPointerX = coords->x;
        mPointerY = coords->y;
    }
}

void DemoScene::OnPointerMove(int pointerId, const struct PointerCoords *coords) {
    if (coords->isScreen && mPointerDown) {
        mPointerX = coords->x;
        mPointerY = coords->y;
    }
}

void DemoScene::OnPointerUp(int pointerId, const struct PointerCoords *coords) {
    if (coords->isScreen) {
        mPointerX = coords->x;
        mPointerY = coords->y;
        mPointerDown = false;
        mSimulatedClickState = SIMULATED_CLICK_NONE;
    }
}

void DemoScene::UpdateUIInput() {
    ImGuiIO &io = ImGui::GetIO();
    io.MousePos = ImVec2(mPointerX, mPointerY);
    bool pointerDown = false;
    // To make a touch work like a mouse click we need to sequence the following:
    // 1) Position cursor at touch spot with mouse button still up
    // 2) Signal mouse button down for a frame
    // 3) Release mouse button (even if touch is still held down)
    // 4) Reset to allow another 'click' once the touch is released
    if (mSimulatedClickState == SIMULATED_CLICK_NONE && mPointerDown) {
        mSimulatedClickState = SIMULATED_CLICK_DOWN;
    } else if (mSimulatedClickState == SIMULATED_CLICK_DOWN) {
        pointerDown = true;
        mSimulatedClickState = SIMULATED_CLICK_UP;
    }
    io.MouseDown[0] = pointerDown;
}


void DemoScene::RenderUI() {
    SetupUIWindow();
    GenerateUI();

    ImGui::End();
    ImGui::PopStyleVar();
}

void DemoScene::SetupUIWindow() {
    ImGuiIO &io = ImGui::GetIO();
    ImVec2 windowPosition(0.0f, 64.0f);
    ImVec2 minWindowSize(io.DisplaySize.x * 0.95f, io.DisplaySize.y);
    ImVec2 maxWindowSize = io.DisplaySize;
    ImGui::SetNextWindowPos(windowPosition);
    ImGui::SetNextWindowSizeConstraints(minWindowSize, maxWindowSize, NULL, NULL);
    ImGuiWindowFlags windowFlags = ImGuiWindowFlags_NoResize |
                                   ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoMove;
    ImGui::PushStyleVar(ImGuiStyleVar_ScrollbarSize, 32.0f);
    char titleString[64];
    snprintf(titleString, 64, "Play Integrity Codelab");
    ImGui::Begin(titleString, NULL, windowFlags);
}

void DemoScene::OnInstall() {
}

void DemoScene::OnUninstall() {
}

void DemoScene::GenerateUI() {
    if (ImGui::Button("Request Random")) {
        DoRequestRandom();
    }

    if (!mServerRandom.empty()) {
        ImGui::TextWrapped("%s", mServerRandom.c_str());
    }

    GenerateCommandIntegrity();
    GenerateCommandExpress();
    ShowSummary();
}

void DemoScene::GenerateCommandIntegrity() {
}

void DemoScene::GenerateCommandExpress() {
    const auto commandResult =
            NativeEngine::GetInstance()->GetClientManager()->GetOperationResult();
    if (commandResult != ClientManager::SERVER_OPERATION_PENDING &&
            !mExpressToken.empty()) {
        if (ImGui::Button("Call server with express token")) {
            DoCommandExpress();
        }
    }
}

void DemoScene::ShowSummary() {
    ClientManager *clientManager = NativeEngine::GetInstance()->GetClientManager();
    const auto commandResult = clientManager->GetOperationResult();
    if (commandResult != ClientManager::SERVER_OPERATION_PENDING) {
        const std::string &summary = clientManager->GetCurrentSummary();
        if (!summary.empty()) {
            ImVec4 textColor = commandResult == ClientManager::SERVER_OPERATION_SUCCESS ?
                    TEXTCOLOR_GREEN : TEXTCOLOR_WHITE;
            ImGui::TextColored(textColor, "%s", summary.c_str());
            mExpressToken = clientManager->GetCurrentExpressToken();
        }
    }
}

void DemoScene::DoRequestRandom() {
    ClientManager *clientManager = NativeEngine::GetInstance()->GetClientManager();
    clientManager->RequestRandom();
    mServerRandom = clientManager->GetCurrentRandomString();
}

void DemoScene::DoCommandIntegrity() {
}

void DemoScene::DoCommandExpress() {
    ClientManager *clientManager = NativeEngine::GetInstance()->GetClientManager();
    clientManager->StartCommandExpress();
    mExpressToken = clientManager->GetCurrentExpressToken();
    mServerRandom = mExpressToken;
}

